# 设计模式


| 序号 |          模式名称和代码链接          |          模式类型          | 描述 |
| :--: | :----------------------------------: | :--: | :--: |
|  1   | [抽象工厂模式](./AbstractFactory.php) | 创建型 | **抽象工厂模式**在不指定具体类的情况下创建一系列相关或依赖对象。 通常创建的类都实现相同的接口。 抽象工厂的客户并不关心这些对象是如何创建的，它只是知道它们是如何一起运行的。 |
|  2   | [建造者模式](./Builder.php) | 创建型 | **建造者模式**是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程， 它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。 |
|  3  | [工厂方法模式](./FactoryMethod.php) | 创建型 | 在**工厂方法模式**中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成 |
|  4   | [多例模式](Multi.php) | 创建型 | **多例模式**是指存在一个类有多个相同实例，而且该实例都是该类本身。 多例类可以有多个实例， 多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。 多例模式实际上就是单例模式的推广。 |
|  5   | [对象池模式](Pooler.php) | 创建型 | **对象池模式**是一种提前准备了一组已经初始化了的对象『池』而不是按需创建或者销毁的创建型设计模式。 |
|  6   | [原型模式](./PrototypePattern.php) | 创建型 | **原型模式**是用于创建重复的对象，同时又能保证性能。 |
|  7   | [简单工厂模式](./SimpleFactory.php) | 创建型 | **简单工厂模式**是一个精简版的工厂模式。 它与静态工厂模式最大的区别是它不是『静态』的。 |
|  8   | [单例模式](./Singleton.php) | 创建型 | 在应用程序调用的时候，只能获得一个对象实例。 |
|  9   | [静态工厂模式](./StaticFactory.php) | 创建型 | 与抽象工厂模式类似，此模式用于创建一系列相关或相互依赖的对象。 **『静态工厂模式』**与**『抽象工厂模式』**的区别在于，只使用一个静态方法来创建所有类型对象， 此方法通常被命名为 `factory` 或 `build`。 |
|  10  | [适配器模式](./Adapter.php) | 结构型 | 将一个类的接口转换成可应用的兼容接口。适配器使原本由于接口不兼容而不能一起工作的那些类可以一起工作。如：客户端数据库适配器 |
|  11  | [桥接模式](./Bridge.php) | 结构型 | 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 |
|  12  | [组合模式](./Composite.php) | 结构型 | 一组对象与该对象的单个实例的处理方式一致。 |
|  13  | [数据映射模式](./DataMapper.php) | 结构型 | 数据映射器是一种数据访问层，它执行持久性数据存储（通常是关系数据库）和内存数据表示（域层）之间的数据双向传输。_ |
|  14  | [装饰模式](./Decorator.php) | 结构型 | 为类实例动态增加新的功能。 |
|  15  | [依赖注入模式](./DependencyInjection.php) | 结构型 | 用松散耦合的方式来更好的实现可测试、可维护和可扩展的代码。 |
|  16  | [门面模式](./Facade.php) | 结构型 | **门面模式(外观模式)**，是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。 |
|  17  | [流接口模式](./FluentInterface.php) | 结构型 | **流接口（Fluent Interface）**是指实现一种面向对象的、能提高代码可读性的 API 的方法，其目的就是可以编写具有自然语言一样可读性的代码，我们对这种代码编写方式还有一个通俗的称呼 —— 方法链。 |
|  18  | [享元模式](./Flyweight.php) | 结构型 | **享元模式（Flyweight Pattern**主要用于减少创建对象的数量，以减少内存占用和提高性能,它提供了减少对象数量从而改善应用所需的对象结构的方式。_ |
|  19  | [代理模式](./Proxy.php) | 结构型 | **代理模式（Proxy）**为其他对象提供一种代理以控制对这个对象的访问。使用代理模式创建代理对象，让代理对象控制目标对象的访问（目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象），并且可以在不改变目标对象的情况下添加一些额外的功能。 |
|  20  | [注册模式](./Registry.php) | 结构型 | **注册模式**是一种常见的设计模式，主要就是将多个实例注册到一个统一的注册器中，然后通过方法直接去调用需要的实例。 |
|  21  | [责任链模式](./ChainOfResponsibilities.php) | 行为型 | 使多个对象都有处理请求的机会，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着这条链一直传递该请求，直到有对象处理它为止。 |
|  22  | [命令模式](./Command.php) | 行为型 | **命令模式**，封装了方法调用细节，以解耦请求者与执行者。 |
|  23  | [迭代器模式](./Iterator.php) | 行为型 | **迭代器模式（Iterator）**，提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 |
|  24  | [中介者模式](./Mediator.php) | 行为型 | **中介者模式**就是用一个中介者封装所有的调用对象，然后用户通过中介者来调用相应的功能，并不需要其它各个类之间相互包含引用，这样可以达到松耦合的目的。 |
|  25  | [备忘录模式](./Memento.php) | 行为型 | **备忘录模式**是一种软件[设计模式](https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 |
| 26 | [空对象模式](./NullObject.php) | 行为型 | **空对象模式**不属于 GoF 设计模式，但是它作为一种经常出现的套路足以被视为设计模式 |
| 27 | [观察者模式](./Observer.php) | 行为型 | **观察者模式（Observer）**，又叫**发布-订阅模式（Publish/Subscribe）**，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。_ |
| 28 | [规格模式](./Specification.php) | 行为型 | 构建一个清晰的业务规则规范，其中每条规则都能被针对性地检查。每个规范类中都有一个称为`isSatisfiedBy`的方法，方法判断给定的规则是否满足规范从而返回 true 或 false |
| 29 | [状态模式](./State.php) | 行为型 | 状态模式可以基于一个对象的同种事务而封装出不同的行为。它提供一种简洁的方式使得对象在运行时可以改变自身行为，而不必借助单一庞大的条件判断语句。 |
| 30 | [策略模式](./Strategy.php) | 行为型 | 指的是对象具备某个行为，但是在不同的场景中，该行为有不同的实现算法。 |
| 31 | [模板方法模式](./TemplateMethod.php) | 行为型 | **模板方法模式**，定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。 |
| 32 | [访问者模式](./Visitor.php) | 行为型 | 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 |
| 33 | [委托模式](./Delegation.php) | 其他 | 一个对象将它要执行的任务委派给与之关联的帮助对象去执行。 |
| 34 | [服务定位器模式](./ServiceLocator.php) | 其他 | 服务定位器模式被一些人认为是一种反面模式。它违反了依赖倒置原则。该模式隐藏类的依赖，而不是暴露依赖（如果暴露可通过依赖注入的方式注入依赖）。当某项服务的依赖发生变化时，使用该服务的类的功能将面临被破坏的风险，最终导致系统难以维护。 |
| 35 | [资源库模式](./Repository.php) | 其他 | 该模式通过提供集合风格的接口来访问领域对象，从而协调领域和数据映射层。 资料库模式封装了一组存储在数据存储器里的对象和操作它们的方面，这样子为数据持久化层提供了更加面向对象的视角。资料库模式同时也达到了领域层与数据映射层之间清晰分离，单向依赖的目的。 |
| 36 | [实体属性值模式](./EAV.php) | 其他 | 实体属性值模型（Entity-attribute-value EAV）是一种用数据模型描述实体的属性（属性，参数） |


**个人博客**: [https://www.classmatelin.top](https://www.classmatelin.top)
